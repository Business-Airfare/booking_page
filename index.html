// supabase/functions/start_payment/index.ts
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "npm:@supabase/supabase-js@2";

/* =========================
   CORS (Squarespace â†’ Supabase)
========================= */
function cors(origin: string | null) {
  const allow = new Set([
    "https://www.business-airfare.com",
    "https://business-airfare.com",
    "https://booking.business-airfare.com",
  ]);
  const o = origin && allow.has(origin) ? origin : "https://www.business-airfare.com";
  return {
    "access-control-allow-origin": o,
    "access-control-allow-methods": "POST, OPTIONS",
    "access-control-allow-headers": "content-type, authorization",
    "access-control-allow-credentials": "true",
    "vary": "Origin",
  };
}

function json(origin: string | null, status: number, body: unknown) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      ...cors(origin),
      "content-type": "application/json; charset=utf-8",
      "cache-control": "no-store",
    },
  });
}

async function stripeCreateOrReusePI(args: {
  secretKey: string;
  amount: number;
  currency: string;
  publicId: string;
  sessionId: string;
}) {
  const { secretKey, amount, currency, publicId, sessionId } = args;

  // Stripe idempotency: guarantees repeated calls return same PI (no duplicates)
  const idempotencyKey = `start_payment_${publicId}`;

  const form = new URLSearchParams();
  form.set("amount", String(amount));
  form.set("currency", currency.toLowerCase());
  form.set("automatic_payment_methods[enabled]", "true");

  // Helpful metadata for webhooks + reconciliation
  form.set("metadata[public_id]", publicId);
  form.set("metadata[payment_session_id]", sessionId);

  // Optional: show something nice in Stripe dashboard
  form.set("description", `business-airfare payment ${publicId}`);

  const res = await fetch("https://api.stripe.com/v1/payment_intents", {
    method: "POST",
    headers: {
      "authorization": `Bearer ${secretKey}`,
      "content-type": "application/x-www-form-urlencoded",
      "Idempotency-Key": idempotencyKey,
    },
    body: form.toString(),
  });

  const data = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = data?.error?.message || `Stripe error HTTP ${res.status}`;
    throw new Error(msg);
  }

  return {
    id: data.id as string,
    client_secret: data.client_secret as string,
    status: data.status as string,
  };
}

async function stripeRetrievePI(secretKey: string, piId: string) {
  const res = await fetch(`https://api.stripe.com/v1/payment_intents/${encodeURIComponent(piId)}`, {
    method: "GET",
    headers: { "authorization": `Bearer ${secretKey}` },
  });
  const data = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = data?.error?.message || `Stripe retrieve error HTTP ${res.status}`;
    throw new Error(msg);
  }
  return {
    id: data.id as string,
    client_secret: data.client_secret as string,
    status: data.status as string,
    amount: data.amount as number,
    currency: data.currency as string,
  };
}

serve(async (req) => {
  const origin = req.headers.get("origin");

  if (req.method === "OPTIONS") return new Response(null, { status: 204, headers: cors(origin) });
  if (req.method !== "POST") return json(origin, 405, { error: "Method not allowed" });

  try {
    const stripeSecret = Deno.env.get("STRIPE_SECRET_KEY");
    if (!stripeSecret) return json(origin, 500, { error: "Missing STRIPE_SECRET_KEY in Supabase secrets" });

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const serviceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
    const db = createClient(supabaseUrl, serviceKey, { auth: { persistSession: false } });

    let body: any;
    try { body = await req.json(); }
    catch { return json(origin, 400, { error: "Invalid JSON body" }); }

    const public_id = String(body?.public_id ?? "").trim();
    if (!public_id) return json(origin, 400, { error: "public_id is required" });

    // Provider-agnostic slot; for now we only support stripe in Phase B
    const payment_provider = "stripe";

    // 1) Read session
    const { data: s, error: sErr } = await db
      .from("payment_sessions")
      .select([
        "id",
        "public_id",
        "status",
        "expires_at",
        "paid_at",
        "payment_started_at",
        "final_amount",
        "total_amount",
        "currency",
        "payment_provider",
        "provider_payment_id",
      ].join(","))
      .eq("public_id", public_id)
      .maybeSingle();

    if (sErr) return json(origin, 500, { error: "DB error", details: sErr.message });
    if (!s) return json(origin, 404, { error: "Not found" });

    const now = Date.now();
    const expMs = s.expires_at ? new Date(s.expires_at).getTime() : null;
    const isExpired = expMs !== null && expMs <= now;

    if (s.paid_at) {
      return json(origin, 409, { error: "Already paid", ui: { selection_locked: true, payment_enabled: false, reason_disabled: "paid" } });
    }
    if (isExpired || s.status === "expired") {
      return json(origin, 409, { error: "Expired", ui: { selection_locked: true, payment_enabled: false, reason_disabled: "expired" } });
    }
    if (s.status !== "active") {
      return json(origin, 409, { error: "Inactive", ui: { selection_locked: true, payment_enabled: false, reason_disabled: s.status } });
    }

    // 2) Ensure payment_started_at is set (sets final_amount = total_amount on first start)
    if (!s.payment_started_at) {
      const { data: started, error: uErr } = await db
        .from("payment_sessions")
        .update({
          payment_started_at: new Date().toISOString(),
          payment_provider: payment_provider,
          // Set final_amount = total_amount on first start (trigger may do this, but we ensure it)
          final_amount: s.total_amount,
        })
        .eq("id", s.id)
        .is("payment_started_at", null)
        .is("paid_at", null)
        .eq("status", "active")
        .gt("expires_at", new Date().toISOString())
        .select("payment_started_at, final_amount, total_amount, currency, payment_provider, provider_payment_id")
        .maybeSingle();

      if (uErr) return json(origin, 500, { error: "DB error starting payment", details: uErr.message });

      // If someone else started it in parallel, just re-read later
      if (started) {
        s.payment_started_at = started.payment_started_at;
        s.final_amount = started.final_amount;
        s.total_amount = started.total_amount;
        s.currency = started.currency;
        s.payment_provider = started.payment_provider;
        s.provider_payment_id = started.provider_payment_id;
      }
    }

    // 3) Re-fetch session to get latest total_amount (in case it changed after payment started)
    const { data: latest, error: latestErr } = await db
      .from("payment_sessions")
      .select("total_amount, final_amount, currency")
      .eq("id", s.id)
      .maybeSingle();

    if (latestErr) return json(origin, 500, { error: "DB error fetching latest amount", details: latestErr.message });
    
    // Use latest total_amount (selection may have changed after payment started)
    // If final_amount exists, use it (it should have been updated by update_selection)
    // Otherwise use total_amount (backward compatibility for sessions that started before this change)
    const currentTotal = Number(latest?.total_amount ?? s.total_amount);
    const currentFinal = Number(latest?.final_amount ?? s.final_amount ?? currentTotal);
    
    // Use final_amount if it exists and matches current total, otherwise use total_amount
    // This ensures we use the correct amount even if selection changed
    const frozenAmount = (currentFinal === currentTotal) ? currentFinal : currentTotal;
    
    if (!Number.isInteger(frozenAmount) || frozenAmount < 0) {
      return json(origin, 500, { error: "Invalid frozen amount" });
    }
    const currency = String(latest?.currency ?? s.currency ?? "USD").toUpperCase();

    // 4) If we already have a provider_payment_id, check if amount needs updating
    if (s.provider_payment_id) {
      const pi = await stripeRetrievePI(stripeSecret, s.provider_payment_id);
      
      // If the PaymentIntent amount doesn't match our current amount, update it
      if (pi.amount !== frozenAmount) {
        // Try to update the PaymentIntent
        const form = new URLSearchParams();
        form.set("amount", String(frozenAmount));
        
        const updateRes = await fetch(`https://api.stripe.com/v1/payment_intents/${encodeURIComponent(pi.id)}`, {
          method: "POST",
          headers: {
            "authorization": `Bearer ${stripeSecret}`,
            "content-type": "application/x-www-form-urlencoded",
          },
          body: form.toString(),
        });

        const updateData = await updateRes.json().catch(() => ({}));
        if (updateRes.ok) {
          // Successfully updated, use new client_secret
          const updatedPI = {
            id: updateData.id as string,
            client_secret: updateData.client_secret as string,
            status: updateData.status as string,
          };
          
          // Update final_amount in database to match
          await db
            .from("payment_sessions")
            .update({ final_amount: frozenAmount })
            .eq("id", s.id)
            .catch(() => {}); // Best effort
          
          // Log the update
          await db.from("payment_events").insert({
            payment_session_id: s.id,
            event_type: "stripe_pi_updated_via_start_payment",
            data: {
              provider_payment_id: updatedPI.id,
              old_amount: pi.amount,
              new_amount: frozenAmount,
              currency,
            },
          }).catch(() => {});
          
          return json(origin, 200, {
            ok: true,
            public_id: s.public_id,
            payment_started_at: s.payment_started_at,
            currency,
            final_amount: frozenAmount,
            provider: "stripe",
            provider_payment_id: updatedPI.id,
            client_secret: updatedPI.client_secret,
            ui: { selection_locked: false, payment_enabled: true, reason_disabled: null },
          });
        } else {
          // Could not update PaymentIntent (might be in a state that can't be updated)
          // Log error but still return the existing PaymentIntent
          await db.from("payment_events").insert({
            payment_session_id: s.id,
            event_type: "stripe_pi_update_failed_via_start_payment",
            data: {
              provider_payment_id: pi.id,
              attempted_amount: frozenAmount,
              current_amount: pi.amount,
              error: updateData?.error?.message || "Unknown error",
            },
          }).catch(() => {});
          
          // Return existing PaymentIntent but warn that amount might be different
          return json(origin, 200, {
            ok: true,
            public_id: s.public_id,
            payment_started_at: s.payment_started_at,
            currency,
            final_amount: pi.amount, // Use PaymentIntent amount since we couldn't update it
            provider: "stripe",
            provider_payment_id: pi.id,
            client_secret: pi.client_secret,
            ui: { selection_locked: false, payment_enabled: true, reason_disabled: null },
            warning: "PaymentIntent amount could not be updated. Current amount may differ from selection.",
          });
        }
      }
      
      // Amount matches, return existing PaymentIntent
      return json(origin, 200, {
        ok: true,
        public_id: s.public_id,
        payment_started_at: s.payment_started_at,
        currency,
        final_amount: frozenAmount,
        provider: "stripe",
        provider_payment_id: pi.id,
        client_secret: pi.client_secret,
        ui: { selection_locked: false, payment_enabled: true, reason_disabled: null },
      });
    }

    // 5) Create PaymentIntent (idempotent per public_id)
    const pi = await stripeCreateOrReusePI({
      secretKey: stripeSecret,
      amount: frozenAmount,
      currency,
      publicId: s.public_id,
      sessionId: s.id,
    });

    // 6) Store PI id in provider_payment_id and ensure final_amount is set (provider-agnostic)
    const { error: saveErr } = await db
      .from("payment_sessions")
      .update({
        payment_provider: "stripe",
        provider_payment_id: pi.id,
        final_amount: frozenAmount, // Ensure final_amount matches PaymentIntent amount
      })
      .eq("id", s.id);

    if (saveErr) return json(origin, 500, { error: "DB error saving provider_payment_id", details: saveErr.message });

    // 7) Record attempt (provider-agnostic)
    await db.from("payment_attempts").insert({
      payment_session_id: s.id,
      provider: "stripe",
      provider_payment_id: pi.id,
      status: "created",
    });

    return json(origin, 200, {
      ok: true,
      public_id: s.public_id,
      payment_started_at: s.payment_started_at,
      currency,
      final_amount: frozenAmount,
      provider: "stripe",
      provider_payment_id: pi.id,
      client_secret: pi.client_secret,
      ui: { selection_locked: false, payment_enabled: true, reason_disabled: null },
    });

  } catch (e) {
    return json(origin, 500, { error: "Server error", details: String(e) });
  }
});
